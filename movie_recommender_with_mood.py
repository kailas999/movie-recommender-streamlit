{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "97d53947-9903-4b7c-80ef-a4ad7ec4fde4",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-06-25 21:30:03.201 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\kailas\\AppData\\Roaming\\Python\\Python312\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n",
      "2025-06-25 21:30:03.490 Session state does not function when running a script without `streamlit run`\n"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import requests\n",
    "from sklearn.feature_extraction.text import TfidfVectorizer\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "\n",
    "# 🎭 Mood to genre mapping\n",
    "MOOD_GENRE_MAP = {\n",
    "    \"Happy 😊\": [\"Comedy\", \"Adventure\", \"Family\"],\n",
    "    \"Sad 😢\": [\"Drama\", \"Romance\", \"Biography\"],\n",
    "    \"Bored 😐\": [\"Action\", \"Thriller\", \"Sci-Fi\"],\n",
    "    \"Inspired 💡\": [\"Documentary\", \"History\"],\n",
    "    \"Romantic ❤️\": [\"Romance\", \"Music\"]\n",
    "}\n",
    "\n",
    "# TMDB API Key\n",
    "TMDB_API_KEY = \"b134830ef4bfd4ae256a4046ee695176\"\n",
    "\n",
    "# Load Data\n",
    "def load_data():\n",
    "    df = pd.read_csv(\"movies.csv\")\n",
    "    df.dropna(subset=['genres'], inplace=True)\n",
    "    df.reset_index(drop=True, inplace=True)\n",
    "    return df\n",
    "\n",
    "# Compute Similarity Matrix\n",
    "def compute_similarity(df):\n",
    "    vectorizer = TfidfVectorizer(stop_words='english')\n",
    "    feature_vectors = vectorizer.fit_transform(df['genres'])\n",
    "    similarity = cosine_similarity(feature_vectors)\n",
    "    return similarity\n",
    "\n",
    "# Recommend Movies by Title\n",
    "def recommend(movie_title, df, similarity):\n",
    "    if movie_title not in df['title'].values:\n",
    "        return []\n",
    "    index = df[df['title'] == movie_title].index[0]\n",
    "    similarity_scores = list(enumerate(similarity[index]))\n",
    "    sorted_movies = sorted(similarity_scores, key=lambda x: x[1], reverse=True)[1:11]\n",
    "    return [(df.iloc[i]['title'], round(score, 3)) for i, score in sorted_movies]\n",
    "\n",
    "# Recommend Movies by Mood\n",
    "def recommend_by_mood(mood, df):\n",
    "    genres_for_mood = MOOD_GENRE_MAP.get(mood, [])\n",
    "    mood_movies = df[df['genres'].apply(lambda g: any(genre in g for genre in genres_for_mood))]\n",
    "    return mood_movies.sample(min(10, len(mood_movies))) if not mood_movies.empty else []\n",
    "\n",
    "# Fetch movie poster and overview using TMDB\n",
    "def fetch_movie_details(movie_name):\n",
    "    url = f\"https://api.themoviedb.org/3/search/movie?api_key={TMDB_API_KEY}&query={movie_name}\"\n",
    "    response = requests.get(url)\n",
    "    data = response.json()\n",
    "    if data['results']:\n",
    "        poster_path = data['results'][0].get('poster_path')\n",
    "        overview = data['results'][0].get('overview', 'No description available.')\n",
    "        full_poster_url = f\"https://image.tmdb.org/t/p/w500{poster_path}\" if poster_path else None\n",
    "        return full_poster_url, overview\n",
    "    return None, \"No description available.\"\n",
    "\n",
    "# Streamlit UI\n",
    "def main():\n",
    "    st.set_page_config(page_title=\"Movie Recommender\", layout=\"centered\")\n",
    "    st.title(\"🎬 Movie Recommendation Engine\")\n",
    "\n",
    "    df = load_data()\n",
    "    similarity = compute_similarity(df)\n",
    "\n",
    "    st.subheader(\"🎯 Recommend by Movie Title\")\n",
    "    movie_list = df['title'].values\n",
    "    selected_movie = st.selectbox(\"Choose a movie to get recommendations:\", movie_list)\n",
    "\n",
    "    if st.button(\"Recommend by Title\"):\n",
    "        recommendations = recommend(selected_movie, df, similarity)\n",
    "        if recommendations:\n",
    "            st.subheader(f\"Top 10 movies similar to '{selected_movie}':\")\n",
    "            for title, score in recommendations:\n",
    "                st.markdown(f\"### 🎬 {title} (Score: {score})\")\n",
    "                poster_url, overview = fetch_movie_details(title)\n",
    "                if poster_url:\n",
    "                    st.image(poster_url, width=200)\n",
    "                st.write(overview)\n",
    "                st.markdown(\"---\")\n",
    "        else:\n",
    "            st.warning(\"Movie not found in dataset.\")\n",
    "\n",
    "    st.subheader(\"🎭 Recommend by Mood\")\n",
    "    selected_mood = st.selectbox(\"Select your mood:\", list(MOOD_GENRE_MAP.keys()))\n",
    "\n",
    "    if st.button(\"Recommend by Mood\"):\n",
    "        mood_movies = recommend_by_mood(selected_mood, df)\n",
    "        if len(mood_movies) > 0:\n",
    "            st.subheader(f\"Movies to watch when you're feeling {selected_mood}:\")\n",
    "            for _, row in mood_movies.iterrows():\n",
    "                st.markdown(f\"### 🎥 {row['title']}\")\n",
    "                poster_url, overview = fetch_movie_details(row['title'])\n",
    "                if poster_url:\n",
    "                    st.image(poster_url, width=200)\n",
    "                st.write(overview)\n",
    "                st.markdown(\"---\")\n",
    "        else:\n",
    "            st.warning(\"No movies found for this mood.\")\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
